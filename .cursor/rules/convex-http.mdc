---
description: Guidelines for creating HTTP endpoints and webhooks in Convex
globs: **/*.ts
alwaysApply: false
---

# Convex HTTP Endpoints

## Basic HTTP Endpoint Setup

HTTP endpoints are defined in `convex/http.ts` and require an `httpAction` decorator:

```typescript
// convex/http.ts
import { httpRouter } from 'convex/server';
import { httpAction } from './_generated/server';

const http = httpRouter();

// Basic GET endpoint
http.route({
  path: '/api/health',
  method: 'GET',
  handler: httpAction(async (ctx, req) => {
    return new Response('OK', { status: 200 });
  }),
});

// Basic POST endpoint
http.route({
  path: '/api/echo',
  method: 'POST',
  handler: httpAction(async (ctx, req) => {
    const body = await req.text();
    return new Response(body, {
      status: 200,
      headers: { 'Content-Type': 'text/plain' },
    });
  }),
});

export default http;
```

## Request Handling

### Reading Request Data

```typescript
// JSON body
http.route({
  path: '/api/users',
  method: 'POST',
  handler: httpAction(async (ctx, req) => {
    const data = await req.json();

    // Validate with Zod
    const parsed = z
      .object({
        name: z.string(),
        email: z.string().email(),
      })
      .parse(data);

    // Process data
    const userId = await ctx.runMutation(internal.users.create, parsed);

    return Response.json({ userId }, { status: 201 });
  }),
});

// Form data
http.route({
  path: '/api/upload',
  method: 'POST',
  handler: httpAction(async (ctx, req) => {
    const formData = await req.formData();
    const file = formData.get('file') as File;

    if (!file) {
      return new Response('No file provided', { status: 400 });
    }

    const bytes = await file.arrayBuffer();
    const blob = new Blob([bytes]);

    // Store in Convex storage
    const storageId = await ctx.storage.store(blob);

    return Response.json({ storageId });
  }),
});

// Query parameters
http.route({
  path: '/api/search',
  method: 'GET',
  handler: httpAction(async (ctx, req) => {
    const url = new URL(req.url);
    const query = url.searchParams.get('q');
    const limit = parseInt(url.searchParams.get('limit') || '10');

    const results = await ctx.runQuery(internal.search.findItems, {
      query: query || '',
      limit,
    });

    return Response.json(results);
  }),
});
```

### Headers and Authentication

```typescript
http.route({
  path: '/api/protected',
  method: 'GET',
  handler: httpAction(async (ctx, req) => {
    // Check authorization header
    const authHeader = req.headers.get('Authorization');
    if (!authHeader?.startsWith('Bearer ')) {
      return new Response('Unauthorized', { status: 401 });
    }

    const token = authHeader.slice(7);

    // Verify token
    const user = await ctx.runQuery(internal.auth.verifyToken, { token });
    if (!user) {
      return new Response('Invalid token', { status: 401 });
    }

    // Return protected data
    const data = await ctx.runQuery(internal.data.getProtected, {
      userId: user._id,
    });

    return Response.json(data);
  }),
});
```

## Webhook Endpoints

### Stripe Webhook Example

```typescript
http.route({
  path: '/webhooks/stripe',
  method: 'POST',
  handler: httpAction(async (ctx, req) => {
    const signature = req.headers.get('stripe-signature');
    if (!signature) {
      return new Response('No signature', { status: 400 });
    }

    const body = await req.text();

    // Verify webhook (in a real app, use Stripe SDK)
    const isValid = await ctx.runAction(internal.stripe.verifyWebhook, {
      body,
      signature,
    });

    if (!isValid) {
      return new Response('Invalid signature', { status: 400 });
    }

    const event = JSON.parse(body);

    // Process different event types
    switch (event.type) {
      case 'payment_intent.succeeded':
        await ctx.runMutation(internal.payments.markPaid, {
          paymentIntentId: event.data.object.id,
        });
        break;

      case 'customer.subscription.deleted':
        await ctx.runMutation(internal.subscriptions.cancel, {
          subscriptionId: event.data.object.id,
        });
        break;

      default:
        console.info(`Unhandled event type: ${event.type}`);
    }

    return new Response('OK', { status: 200 });
  }),
});
```

### GitHub Webhook Example

```typescript
http.route({
  path: '/webhooks/github',
  method: 'POST',
  handler: httpAction(async (ctx, req) => {
    const event = req.headers.get('X-GitHub-Event');
    const signature = req.headers.get('X-Hub-Signature-256');

    if (!event || !signature) {
      return new Response('Missing headers', { status: 400 });
    }

    const body = await req.json();

    // Handle different GitHub events
    if (event === 'push') {
      await ctx.runMutation(internal.github.processPush, {
        repository: body.repository.full_name,
        commits: body.commits,
      });
    } else if (event === 'pull_request') {
      await ctx.runMutation(internal.github.processPR, {
        action: body.action,
        pr: body.pull_request,
      });
    }

    return new Response('OK', { status: 200 });
  }),
});
```

## File Downloads

```typescript
http.route({
  path: '/api/download/:fileId',
  method: 'GET',
  handler: httpAction(async (ctx, req) => {
    // Extract path parameter
    const url = new URL(req.url);
    const fileId = url.pathname.split('/').pop();

    if (!fileId) {
      return new Response('File ID required', { status: 400 });
    }

    // Get file from storage
    const file = await ctx.runQuery(internal.files.get, {
      fileId: fileId as Id<'files'>,
    });

    if (!file) {
      return new Response('File not found', { status: 404 });
    }

    // Get blob from storage
    const blob = await ctx.storage.get(file.storageId);
    if (!blob) {
      return new Response('File data not found', { status: 404 });
    }

    // Return file with appropriate headers
    return new Response(blob, {
      headers: {
        'Content-Type': file.mimeType || 'application/octet-stream',
        'Content-Disposition': `attachment; filename="${file.name}"`,
      },
    });
  }),
});
```

## CORS Configuration

```typescript
// Helper function for CORS headers
function corsHeaders(origin?: string | null) {
  return {
    'Access-Control-Allow-Origin': origin || '*',
    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    'Access-Control-Max-Age': '86400',
  };
}

// Handle preflight requests
http.route({
  path: '/api/*',
  method: 'OPTIONS',
  handler: httpAction(async (ctx, req) => {
    return new Response(null, {
      status: 204,
      headers: corsHeaders(req.headers.get('Origin')),
    });
  }),
});

// Add CORS to other endpoints
http.route({
  path: '/api/data',
  method: 'GET',
  handler: httpAction(async (ctx, req) => {
    const data = await ctx.runQuery(internal.data.getPublic, {});

    return Response.json(data, {
      headers: corsHeaders(req.headers.get('Origin')),
    });
  }),
});
```

## Rate Limiting

```typescript
http.route({
  path: '/api/limited',
  method: 'POST',
  handler: httpAction(async (ctx, req) => {
    const ip = req.headers.get('X-Forwarded-For') || 'unknown';

    // Check rate limit
    const allowed = await ctx.runMutation(internal.rateLimit.check, {
      key: `api:${ip}`,
      limit: 100,
      window: 3600000, // 1 hour
    });

    if (!allowed) {
      return new Response('Rate limit exceeded', {
        status: 429,
        headers: {
          'Retry-After': '3600',
        },
      });
    }

    // Process request
    const result = await ctx.runMutation(internal.api.process, {});

    return Response.json(result);
  }),
});
```

## Error Handling

```typescript
http.route({
  path: '/api/process',
  method: 'POST',
  handler: httpAction(async (ctx, req) => {
    try {
      const data = await req.json();

      // Validate input
      const parsed = z
        .object({
          action: z.enum(['create', 'update', 'delete']),
          id: z.string(),
        })
        .safeParse(data);

      if (!parsed.success) {
        return Response.json(
          { error: 'Invalid input', details: parsed.error.flatten() },
          { status: 400 }
        );
      }

      // Process action
      const result = await ctx.runMutation(
        internal.api.processAction,
        parsed.data
      );

      return Response.json(result);
    } catch (error) {
      console.error('API error:', error);

      if (error instanceof ConvexError) {
        return Response.json({ error: error.data.message }, { status: 400 });
      }

      return Response.json({ error: 'Internal server error' }, { status: 500 });
    }
  }),
});
```

## Streaming Responses

```typescript
http.route({
  path: '/api/stream',
  method: 'GET',
  handler: httpAction(async (ctx, req) => {
    const encoder = new TextEncoder();

    const stream = new ReadableStream({
      async start(controller) {
        // Send data in chunks
        for (let i = 0; i < 10; i++) {
          const data = await ctx.runQuery(internal.data.getChunk, { index: i });
          controller.enqueue(
            encoder.encode(`data: ${JSON.stringify(data)}\n\n`)
          );

          // Simulate delay
          await new Promise((resolve) => setTimeout(resolve, 1000));
        }

        controller.close();
      },
    });

    return new Response(stream, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        Connection: 'keep-alive',
      },
    });
  }),
});
```

## Best Practices

1. **Always validate input** using Zod or similar validation library
2. **Use appropriate HTTP status codes** (200 OK, 201 Created, 400 Bad Request, etc.)
3. **Handle errors gracefully** and return meaningful error messages
4. **Implement rate limiting** for public endpoints
5. **Add CORS headers** when endpoints will be accessed from browsers
6. **Use internal functions** to keep business logic separate from HTTP handling
7. **Log important events** for debugging and monitoring
8. **Verify webhooks** using signatures to ensure authenticity
9. **Return consistent response formats** (e.g., always use JSON for APIs)
10. **Document your endpoints** with expected inputs and outputs
