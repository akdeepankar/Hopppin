---
globs: convex/**
alwaysApply: false
---

## Context

Read the files you need in:

- convex/schema.ts - Database schema
- .cursor/rules/convex-ents.mdc - Entity relationships
- .cursor/rules/convex-aggregate.mdc - Efficient counting
- .cursor/rules/convex-optimize.mdc - Performance patterns
- .cursor/rules/convex-search.mdc - Full-text search
- .cursor/rules/convex-streams.mdc - Advanced filtering
- .cursor/rules/convex-trigger.mdc - Database triggers
- .cursor/rules/convex-scheduling.mdc - Cron and scheduled functions
- .cursor/rules/convex-http.mdc - HTTP endpoints
- .cursor/rules/convex-examples.mdc - Reference implementations

## Core Expertise

- **Backend Functions**: Type-safe queries, mutations, actions with auth and rate limiting
- **Schema Design**: Convex Ents schemas, relationships, indexes, and constraints
- **React Integration**: Query/mutation hooks, real-time subscriptions, optimistic updates
- **Authentication**: Auth functions, guards, session management, role-based access
- **Performance**: Efficient queries, pagination, aggregations, caching strategies
- **Real-time**: Live queries, subscriptions, and reactive data
- **Search**: Full-text search with indexing and filtering
- **Storage**: File uploads with Convex storage, presigned URLs
- **Integration**: HTTP endpoints, webhooks, scheduled functions, external APIs

# Convex guidelines (with Convex Ents)

## Authentication & Functions

**Edit:** `convex/functions.ts`, `convex/*.ts` files

### Function wrappers (NEVER use raw query/mutation/action)

```typescript
import {
  createAuthQuery,
  createPublicQuery,
  createAuthMutation,
} from "./functions";
import { z } from "zod";
import { zid } from "convex-helpers/server/zod";

// All function types - use appropriate wrapper
export const example = createAuthQuery()({
  // or createPublicQuery, createAuthMutation, etc.
  args: { id: zid("items") }, // ALWAYS use zid() for IDs
  returns: z.object({ name: z.string() }).nullable(),
  handler: async (ctx, args) => {
    return await ctx.table("items").get(args.id);
  },
});

// Rate limiting & admin
export const createItem = createAuthMutation({
  rateLimit: "character/create", // Auto tier limits
  role: "admin", // Optional role requirement
})({
  args: { name: z.string().min(1).max(100) },
  returns: zid("items"),
  handler: async ({ user, table }, args) => {
    // Destructure context
    await user.patch({ credits: user.credits - 1 });
    return await table("items").insert({ name: args.name, userId: user._id });
  },
});
```

**ctx.user in auth functions:** Type `SessionUser` from `convex/authShared.ts` - includes:

- Full `EntWriter<'users'>` with ent methods
- Computed properties: `isAdmin`, `plan`
- `session: AuthSession` with token, expiresAt, activeOrganizationId, etc.
  **‚ùå AVOID:** `ctx.table('users').get(ctx.userId)` - ctx.user is already loaded!  
  **Always throw ConvexError:** `throw new ConvexError({ code: 'UNAUTHENTICATED', message: 'Not authenticated' });`

### üö® CRITICAL: Rate Limiting Requirements

**EVERY user-facing mutation MUST have rate limiting** to prevent abuse and ensure system stability.

```typescript
// ‚ùå DANGEROUS: Mutation without rate limiting
export const updateProfile = createAuthMutation()({
  args: { bio: z.string() },
  handler: async (ctx, args) => {
    // User can spam this endpoint!
  },
});

// ‚úÖ SECURE: Mutation with rate limiting
export const updateProfile = createAuthMutation({
  rateLimit: "user/update", // REQUIRED!
})({
  args: { bio: z.string() },
  handler: async (ctx, args) => {
    // Protected from spam
  },
});
```

### Rate Limiting

**Edit:** `convex/helpers/rateLimiter.ts`

**üö® CRITICAL: Two-Step Process for Rate Limiting**

When adding rate limiting to ANY mutation, you MUST:

1. **Add the `rateLimit` parameter to your mutation**
2. **Add the rate limit definition to `convex/helpers/rateLimiter.ts`**

```typescript
// STEP 1: Define rate limits in rateLimiter.ts
export const rateLimiter = new RateLimiter(components.rateLimiter, {
  // ‚ö†Ô∏è CRITICAL: Add your new rate limit key here!
  'comment/create:free': { kind: 'fixed window', period: MINUTE, rate: 10 },
  'comment/create:premium': { kind: 'fixed window', period: MINUTE, rate: 30 },

  // Example of adding a new rate limit:
  'profile/update:free': { kind: 'fixed window', period: MINUTE, rate: 20 },
  'profile/update:premium': { kind: 'fixed window', period: MINUTE, rate: 60 },
});

// STEP 2: Use in mutations (auto :free/:premium suffix)
createAuthMutation({ rateLimit: 'comment/create' })({ ... });
createAuthMutation({ rateLimit: 'profile/update' })({ ... }); // Must exist in rateLimiter.ts!
```

### Internal functions

**Edit:** `convex/*.ts` files

```typescript
import { createInternalQuery, createInternalMutation, createInternalAction } from './functions';

export const processData = createInternalQuery()({
  args: { id: zid('items') },
  returns: z.null(),
  handler: async (ctx, args) => { ... }, // Only callable by Convex
});
```

### HTTP endpoints

For HTTP endpoints and webhooks, see [convex-http.mdc](mdc:.cursor/rules/convex-http.mdc).

### Validators

**Edit:** `convex/schema.ts` (schema files ONLY, use `v.` validators)  
**Edit:** `convex/*.ts` files (function files, use `z.` validators)

```typescript
import { defineEnt, defineEntSchema, getEntDefinitions } from "convex-ents";
import { v } from "convex/values";

// Schema example (v.)
const schema = defineEntSchema({
  users: defineEnt({
    name: v.string(),
    role: v.union(v.literal("user"), v.literal("admin")),
  })
    .field("email", v.string(), { unique: true })
    .edge("profile", { ref: true })
    .edges("messages", { ref: true })
    .index("username_name", ["username", "name"]), // ALWAYS put indexes LAST (compound index example)
});

// Function example (z.)
export const createUser = createAuthMutation()({
  args: {
    userId: zid("users"), // CRITICAL: Always zid() for IDs
    name: z.string().min(1).max(100),
    email: z.string().email(),
    tags: z.array(z.string()).max(10),
    bio: z.string().optional(), // Use .optional(), NOT .nullable()
  },
  returns: zid("users"),
  handler: async (ctx, args) => {
    /* ... */
  },
});
```

**Quick Reference:**

| Type     | Schema (v.)                       | Functions (z.)                  |
| -------- | --------------------------------- | ------------------------------- |
| IDs      | `v.id('table')`                   | `zid('table')`                  |
| Strings  | `v.string()`                      | `z.string().min().max()`        |
| Numbers  | `v.number()`                      | `z.number().positive().int()`   |
| Arrays   | `v.array(v.string())` max 8192    | `z.array(z.string()).max(10)`   |
| Objects  | `v.object({...})` max 1024 fields | `z.object({...}).strict()`      |
| Optional | `v.optional(...)`                 | `.optional()` NOT `.nullable()` |
| Enums    | `v.union(v.literal(...))`         | `z.enum([...])`                 |
| Records  | `v.record(...)`                   | `z.record(...)`                 |
| BigInt   | `v.int64()`                       | -                               |

**Null vs undefined in Convex:**

- **Database fields:** Convex returns `undefined` for missing optional fields (NOT `null` like Prisma)
- **Function args:** Use `.optional()` for optional arguments (can be omitted), use `null` to unset fields
- **Function returns:**
  - Use `.optional()` for optional fields
  - Use `.nullable()` ONLY when function explicitly returns `null` (like `continueCursor`)
- **Patch operations:** Use `undefined` to unset fields if arg field is `null`
  **Document IDs:**

- **Function args/returns:** ALWAYS use `zid('tableName')`, never `z.string()`
- **TypeScript:** Use `Id<'tableName'>` type
- **External IDs:** Cast with `as Id<'tasks'>` when needed

### Function types summary

**Public functions** (exposed to internet):

- `createPublicQuery()` - auth optional
- `createAuthQuery()` - requires auth
- `createPublicMutation()` - auth optional + NEEDS rate limiting
- `createAuthMutation()` - requires auth + NEEDS rate limiting
- `createPublicPaginatedQuery()` - with pagination
- `createAuthPaginatedQuery()` - auth + pagination
- `createAction()` - public actions + NEEDS rate limiting for mutations

**Internal functions** (only callable by Convex, NOT even by NextJS server):

- `createInternalQuery/Mutation/Action()` - NO rate limiting needed
- `createAuthInternalQuery()` - requires auth

**Rules:**

- CRITICAL: NEVER use raw `query`, `mutation`, `action` from `./_generated/server`
- ALWAYS include `args` and `returns` validators
- ALWAYS add `rateLimit` for user-facing mutations
- Use `returns: z.null()` when no return value

### Function calling

```typescript
// From query/mutation/action
ctx.runQuery(internal.example.getData, args);
ctx.runMutation(internal.example.update, args);
ctx.runAction(internal.example.process, args);

// ‚ö†Ô∏è TypeScript circular reference fix: ALWAYS Type runQuery/runMutation results
const user: { name: string; email: string } | null = await ctx.runQuery(
  internal.userInternal.getUser,
  {}
);
```

**Rules:**

- Use FunctionReference (api/internal), not function directly
- Minimize action‚Üíquery/mutation calls (race conditions)
- Share code via helper functions instead of action chains
- **Type annotations:** Required for circular dependencies in actions

### Function references

**Import:** `import { api, internal } from './_generated/api'`

- **Public:** `api.filename.functionName` (e.g., `api.users.create`)
- **Internal:** `internal.filename.functionName` (e.g., `internal.users.process`)
- **Nested:** `api.folder.file.function` (e.g., `api.messages.access.check`)

### File organization

**Edit:** `convex/` directory

- File-based routing: `convex/users.ts` ‚Üí `api.users.*`
- Group by feature: `users.ts`, `messages.ts`, `auth.ts`
- Use internal functions for sensitive operations

## Validator summary

- **Schema files (`convex/schema.ts`):** Use `v.` validators ONLY
- **Function files (`convex/*.ts`):** Use `z.` validators ONLY
- **Document IDs:** `zid('table')` in functions, `v.id('table')` in schemas
- **Records:** `z.record()` in functions, `v.record()` in schemas

### Pagination

**OPTIMIZATION:** Always use pagination for user-facing lists. See [convex-optimize.mdc](mdc:.cursor/rules/convex-optimize.mdc).

**Note:** Use `paginationOptsValidator` from Convex (not Zod) when manually adding pagination args.

```typescript
// Use createPublicPaginatedQuery() or createAuthPaginatedQuery() (paginationOpts auto-injected)
export const listByAuthor = createPublicPaginatedQuery()({
  args: { author: z.string() },
  handler: async (ctx, args) => {
    return await ctx
      .table("messages", "author", (q) => q.eq("author", args.author))
      .order("desc")
      .paginate(args.paginationOpts)
      .map(async (msg) => ({
        // Ent .map() works after .paginate()
        ...msg.doc(),
        user: await ctx.table("users").get(msg.userId),
      }));
  },
});

// React hooks: usePublicPaginatedQuery, useAuthPaginatedQuery (NEVER use `usePaginatedQuery` directly)
const { data, hasNextPage, isLoading, isFetchingNextPage, fetchNextPage } =
  usePublicPaginatedQuery(
    api.messages.list,
    { author: "alice" }, // args (excluding paginationOpts)
    { initialNumItems: 10 }
  );
```

**Pagination returns:** `page` (array), `isDone` (boolean), `continueCursor` (string | null)  
**Hook returns:** `data` (accumulated items), `hasNextPage`, `isLoading`, `isFetchingNextPage`, `fetchNextPage()`  
**Complex filters:** Use streams for consistent page sizes with pagination

## Schema guidelines

**Edit:** `convex/schema.ts`

```typescript
const schema = defineEntSchema({
  users: defineEnt({ name: v.string() })
    .field("email", v.string(), { unique: true }) // Unique constraint
    .field("role", v.string(), { default: "user" }) // Default value
    .edge("profile", { ref: true }) // 1:1 edge (optional side)
    .edges("messages", { ref: true }) // 1:many edge ("one" side)
    .edges("followers", { to: "users", inverse: "following" }) // Self-referencing
    .index("username_name", ["username", "name"]) // Compound index naming pattern
    .searchIndex("search_username_name", {
      // Search index naming pattern
      searchField: "name",
      filterFields: ["username"],
    }),

  messages: defineEnt({ text: v.string() })
    .edge("user") // 1:many edge ("many" side)
    .edge("author", { field: "authorId", optional: true }) // Optional edge
    .edges("tags"), // many:many edge
});

export default schema;
export const entDefinitions = getEntDefinitions(schema);
```

**Edge patterns:** 1:1 `.edge()` with `{ref:true}` on optional | 1:many `.edges()` on "one", `.edge()` on "many" | many:many `.edges()` both sides

**IMPORTANT: Method ordering!**

1. `defineEnt({...})` - Define regular fields (pass inline in constructor)
2. `.field(...)` - Additional fields with options (unique, default, index)
3. `.edge(...)` / `.edges(...)` - Define relationships
4. `.index(...)` / `.searchIndex(...)` - ALWAYS put indexes LAST

## Index Naming Conventions

**üö® CRITICAL: Follow exact naming patterns for consistency:**

### Standard Indexes

- **Single field:** Use `.field('fieldName', v.type(), { index: true })` - NEVER `.index('fieldName', ['fieldName'])`
- **Compound fields:** `.index('field1_field2', ['field1', 'field2'])`
- **With edge field:** `.index('userId_lastMessageAt', ['userId', 'lastMessageAt'])`
- **Date ordering:** `.index('characterId_endDate', ['characterId', 'endDate'])`

### Search Indexes

- **Pattern:** `.searchIndex('search_<searchField>', { ... })`
- **Examples:**
  - `.searchIndex('search_name', { searchField: 'name', filterFields: ['userId', 'private'] })`
  - `.searchIndex('search_username_name', { searchField: 'name', filterFields: ['username'] })`
  - `.searchIndex('search_title_content', { searchField: 'title', filterFields: [...] })`

### Auto-generated Indexes from Edges

When you define edges, Convex Ents automatically creates indexes:

- `.edge('user')` ‚Üí Creates index on `userId` field
- `.edges('followers', { to: 'users', inverse: 'following' })` ‚Üí Creates indexes on join table

**üö® CRITICAL: NEVER create indexes for edge-generated fields!**

- ‚ùå NEVER: `.index('userId', ['userId'])` when you have `.edge('user')`
- ‚úÖ OK: `.index('userId_status', ['userId', 'status'])` - compound indexes are fine
- **WHY:** Edges automatically create indexes on their ID fields

## Field Options

**Available field options:**

- `{ unique: true }` - Enforce uniqueness constraint
- `{ default: value }` - Default value for new documents
- `{ index: true }` - Create single-field index (alternative to .index())
- `{ optional: true }` - For edge fields that may be null

**Additional Rules:**

- Edges auto-create ID fields - don't define manually
- Create indexes for all equality filters (except edge fields) - see [convex-optimize.mdc](mdc:.cursor/rules/convex-optimize.mdc)

## Import guidelines

**üö® CRITICAL: NEVER use dynamic imports in Convex functions**

Dynamic imports (`await import()`) do NOT work in Convex's serverless environment. Convex requires static analysis of all dependencies at build time.

**From Next.js (`src/`):**

```typescript
import { api, internal } from "@convex/_generated/api";
import { Id, Doc } from "@convex/_generated/dataModel";
import type { Ent, EntWriter } from "@convex/shared/types"; // Ent types
```

**From Convex (`convex/`):**

```typescript
import { api, internal } from "./_generated/api";
import { Id, Doc } from "./_generated/dataModel";
import { entDefinitions } from "./schema"; // Import ent definitions
import { entsTableFactory } from "convex-ents"; // For function context
```

## React Integration guidelines

**Edit:** `src/components/**/*.tsx`

### Query hooks

```typescript
import { usePublicQuery, useAuthQuery } from '@/lib/convex/hooks';

// Public query (auth optional) - ALWAYS pass {} for no args
const { data, isPending } = usePublicQuery(api.items.list, {}); // ALWAYS pass {} for no args
const { data: profile } = useAuthQuery(api.user.getProfile, {}); // Skips if not authenticated
const { data } = usePublicQuery(api.items.get, itemId ? { id: itemId } : 'skip'); // Conditional

if (isPending) return <Skeleton />;
```

**NEVER use** `useQuery` or `usePaginatedQuery` directly

### Skeleton Loading with Convex

**ALWAYS use `WithSkeleton` + `placeholderData`** for consistent skeleton UI:

```typescript
import { WithSkeleton } from '@/components/ui/skeleton';

const { data, isLoading } = useAuthQuery(
  api.character.list,
  {},
  {
    placeholderData: {
      characters: [
        { _id: '1' as any, name: 'Character 1', description: 'Description text' },
        { _id: '2' as any, name: 'Character 2', description: 'Description text' },
      ],
    }
  }
);

return (
  <div>
    {data?.characters?.map((char, index) => (
      <WithSkeleton key={index} isLoading={isLoading}>
        <Card>
          <h3>{char.name}</h3>
          <p>{char.description}</p>
        </Card>
      </WithSkeleton>
    ))}
  </div>
);
```

**Rules:**

- NEVER use random values in mock data (causes hydration errors)
- Keep mock data properties alphabetically ordered
- Use static, predictable mock data matching expected structure
- Use index as key for mock data items when mapping
- DO use `as any` for `_id` or `id` fields in placeholderData (e.g., `_id: '1' as any`)

### Mutations

```typescript
import { usePublicMutation, useAuthMutation } from '@/lib/convex/hooks';

const createItem = usePublicMutation(api.items.create); // Don't destructure
const updateSettings = useAuthMutation(api.user.updateSettings);

// Option 1: toast.promise (with loading state)
toast.promise(updateSettings.mutateAsync({ name: 'New' }), {
  loading: 'Updating...',
  success: 'Updated!',
  error: (e) => e.data?.message ?? 'Failed',
});

// Option 2: callbacks (no loading toast)
const updateSettings = useAuthMutation(api.user.updateSettings, {
  onSuccess: () => toast.success('Updated!'),
  onError: () => toast.error('Failed'),
});

<Button disabled={updateSettings.isPending}>Save</Button>
```

### Other hooks

```typescript
// Actions
import { usePublicAction, useAuthAction } from "@/lib/convex/hooks";
const generateReport = usePublicAction(api.reports.generate);
const processData = useAuthAction(api.data.process);

// One-off queries
import { useConvex } from "convex/react";
const convex = useConvex();
await convex.query(api.items.validate, { id });

// Auth hooks
import { useIsAuth, useCurrentUser } from "@/lib/convex/hooks";
const isAuth = useIsAuth();
const { isLoading, ...user } = useCurrentUser();
```

### Server-side auth (RSC)

```typescript
import {
  getSessionToken,
  getSessionUser,
  isAuth,
  isUnauth,
  fetchAuthQuery,
  fetchAuthQueryOrThrow,
} from "@/lib/convex/server";

// Get session token/user in server components
const token = await getSessionToken(); // Returns string | null
const user = await getSessionUser(); // Returns SessionUser & { token } | null

// Check auth status
if (await isAuth()) {
  /* authenticated */
}
if (await isUnauth()) {
  /* not authenticated */
}

// Fetch authenticated queries in server components
const data = await fetchAuthQuery(api.user.getData, { id: userId });
// Returns null if not authenticated

const data = await fetchAuthQueryOrThrow(api.user.getData, { id: userId });
// Throws error if not authenticated
```

### Auth guards

**Server-side guards (RSC)**:

```typescript
import { authGuard, adminGuard } from "@/lib/convex/rsc";

// In server components/pages
await authGuard(); // Redirects to login if not authenticated
await adminGuard(); // Returns 404 if not admin
```

**Client-side guards (hooks)**:

```typescript
import { useAuthGuard, usePremiumGuard } from "@/lib/convex/hooks";

// Auth guard - shows login modal if not authenticated
const authGuard = useAuthGuard();
if (authGuard(() => console.info("authenticated"))) return; // Blocked

// Premium guards - shows subscription modal if not premium
const premiumGuard = usePremiumGuard();
if (premiumGuard()) return; // Blocked
```

### Relationship patterns with Ents

**Edit:** `convex/*.ts` files

```typescript
// Get entities
const user = await ctx.table("users").get(userId); // Returns null if not found
const userX = await ctx.table("users").getX(userId); // Throws if not found
const userByEmail = await ctx.table("users").get("email", "user@example.com"); // By unique field
const users = await ctx.table("users").getMany([id1, id2, id3]); // Batch - returns (Doc | null)[]
const usersX = await ctx.table("users").getManyX([id1, id2, id3]); // Batch - throws if any missing

// ‚ùå CRITICAL: Never refetch ctx.user in authenticated contexts!
const currentUser = await ctx.table("users").getX(ctx.userId); // WRONG - redundant query!
// ‚úÖ CORRECT: Use pre-loaded user from context
const currentUser = ctx.user; // Already available in authenticated contexts

// Edge traversal - PREFERRED over manual queries
const profile = await user.edge("profile"); // Optional edge (may return null)
const profileX = await user.edgeX("profile"); // Required edge (throws if missing)
const messages = await user.edge("messages").order("desc").take(10); // 1:many edge

// IMPORTANT: Use edgeX when you know the relationship MUST exist
const user = await character.edgeX("user"); // Characters always have a user
const character = await message.edgeX("author"); // If message has required author

// When to use getX/edgeX vs get/edge:
// - Use getX/edgeX: After insert, required relationships, validated entities
// - Use get/edge: Optional relationships, user-provided IDs, deletable entities

// When to use getManyX vs getMany:
// - Use getManyX: IDs from recent query, after insert, must all exist
// - Use getMany: User-provided IDs, potentially deleted, optional entities

// ‚ö†Ô∏è EDGE LIMITATIONS:
// - NO .filter() or .search() on many:many edges - use ctx.table() instead
// - 1:1 and 1:many edges DO support .filter() and .order()
// - NO .search() on any edge type - use ctx.table() instead
// - Entities from edge traversal are read-only (can't .patch()/.delete())
// - All edges support: .order(), .take(), .first(), .paginate(), .map()

// ‚ö†Ô∏è IMPORTANT: .filter() NOT available on many:many edges, .search() NOT available on any edges!
// ‚úÖ CORRECT for many:many edges or when using search: Use ctx.table() for filtering/searching
const activeMessages = await ctx
  .table("messages", "userId", (q) => q.eq("userId", user._id))
  .filter((q) => q.eq(q.field("status"), "active"))
  .take(5);

// ‚úÖ OK for 1:1 and 1:many edges: Can use .filter() and .order()
const activeOrders = await user
  .edge("orders")
  .filter((q) => q.eq(q.field("status"), "active"))
  .order("desc")
  .take(10);

// Many:many edge operations
const isFollowing = await user.edge("following").has(targetUserId); // O(1) check
const tags = await message.edge("tags"); // Get all related tags

// ‚ö†Ô∏è IMPORTANT: Use .has() for O(1) edge existence checks!
// ‚ùå INEFFICIENT: Fetching all to check existence
const following = await user.edge("following");
const isFollowing = following.some((u) => u._id === targetUserId); // O(n)
// ‚úÖ EFFICIENT: Direct existence check
const isFollowing = await user.edge("following").has(targetUserId); // O(1)

// Write operations require re-fetch
const resource = await comment.edge("resources").first();
await ctx.table("resources").getX(resource._id).delete(); // Re-fetch to write

// Ents .map() handles async internally
const enriched = await ctx
  .table("messages")
  .take(10)
  .map(async (msg) => ({
    ...msg.doc(),
    user: await ctx.table("users").get(msg.userId),
  }));

// ‚ö†Ô∏è IMPORTANT: Use Ents .map() for query results, not asyncMap!
// ‚ùå WRONG: Using asyncMap for Ents query results
import { asyncMap } from "convex-helpers";
const users = await ctx.table("users").take(10);
const enriched = await asyncMap(users, async (user) => ({
  ...user,
  profile: await user.edge("profile"),
}));

// ‚úÖ CORRECT: Use built-in .map() for Ents queries
const enriched = await ctx
  .table("users")
  .take(10)
  .map(async (user) => ({
    ...user.doc(),
    profile: await user.edge("profile"),
  }));

// ‚úÖ Use asyncMap ONLY for plain arrays or stream results
const ids = ["id1", "id2", "id3"];
const results = await asyncMap(ids, (id) => someAsyncOperation(id));
```

**Count operations:** Use aggregates, not `.length` - see [convex-aggregate.mdc](mdc:.cursor/rules/convex-aggregate.mdc)  
**asyncMap:** Only needed for non-Ent arrays (plain arrays, stream results)

### Many-to-Many Join Tables

**Auto-generated join tables** (from `.edges()` definitions):

- Created automatically, don't define them in schema
- Have ID fields: `userId`, `characterId`, etc.
- **NO edge support** - access IDs directly:
  ```typescript
  const star = await ctx.table("characterStars").get(starId);
  // ‚ùå WRONG: await star.edge('character')
  // ‚úÖ RIGHT: await ctx.table('characters').get(star.characterId)
  ```

**Manual join tables** (in schema):

**üö® CRITICAL: Join tables are the ONLY place where you manually define ID fields!**

Define manual join tables ONLY when you need:

1. TypeScript types for the join table
2. Aggregates on the join relationship

```typescript
// ‚úÖ CORRECT: Auto-generated join table - manually define ID fields (no edges)
characterStars: defineEnt({})
  .field('userId', v.id('users'), { index: true })
  .field('characterId', v.id('characters'), { index: true })
  .index('userId_characterId', ['userId', 'characterId'])
  .index('characterId_userId', ['characterId', 'userId']),

// ‚úÖ CORRECT: Entity with relationships and custom fields
messageVotes: defineEnt({})
  .field('isDownvoted', v.boolean())
  .edge('user')     // Creates userId field and index
  .edge('message')  // Creates messageId field and index
  .index('userId_messageId', ['userId', 'messageId'])
```

**Regular Table Patterns:**

```typescript
// ‚ùå WRONG: Regular table manually defining ID fields
messages: defineEnt({ text: v.string() }).field("userId", v.id("users"), {
  index: true,
}); // WRONG!

// ‚úÖ CORRECT: Regular table using edges
messages: defineEnt({ text: v.string() }).edge("user"); // Creates userId field and index automatically

// ‚úÖ CORRECT: Table with optional relationship
comments: defineEnt({ content: v.string() }).edge("user", {
  field: "authorId",
  optional: true,
});
```

**Performance:** N+1 is fast (~1ms/doc) | Arrays max 10 items | Use indexes  
**Count Operations:** For counting documents, use [convex-aggregate.mdc](mdc:.cursor/rules/convex-aggregate.mdc) instead of `.length` on collections

## TypeScript guidelines

```typescript
// Document IDs
type UserId = Id<'users'>; // Use Id<T> for document IDs

// Infer complex types (NEVER manually type)
const mainCharacter = await (async () => {
  if (!condition) return null;
  return { id: char._id, image: char.image ?? null }; // Auto-inferred
})();

// Record with IDs
const idToUsername: Record<Id<'users'>, string> = {};

// Auth-aware context (from convex/functions.ts), NEVER use ctx: any
AuthQueryCtx, PublicQueryCtx, AuthMutationCtx, PublicMutationCtx;

// ctx.user in auth contexts is type SessionUser (from convex/authShared.ts):
type SessionUser = {
  // From AuthUser (better-auth fields)
  id: Id<'users'>;
  email: string;
  emailVerified: boolean;
  role?: string | null;
  createdAt: number;
  updatedAt: number;
  banExpires?: number | null;
  banned?: boolean | null;
  banReason?: string | null;

  // From Doc<'users'> (all user table fields)
  _id: Id<'users'>;
  _creationTime: number;
  name?: string;
  image?: string;
  firstName?: string;
  lastName?: string;
  bio?: string;
  location?: string;
  website?: string;
  x?: string;
  github?: string;
  linkedin?: string;
  username: string;
  credits: number;
  monthlyCredits: number;
  mainCharacterId?: Id<'characters'>;
  usernameUpdatedAt?: number;
  deletedAt?: number;

  // Computed properties
  isAdmin: boolean;
  plan?: 'premium' | 'team';

  // Session info
  session: {
    createdAt: number;
    expiresAt: number;
    token: string;
    updatedAt: number;
    userId: string;
    activeOrganizationId?: string | null;
    activeTeamId?: string | null;
    impersonatedBy?: string | null;
    ipAddress?: string | null;
    userAgent?: string | null;
  };

  // Ent methods (for mutations)
  doc: () => Doc<'users'>;
  edge: <Edge extends keyof Edges>(edge: Edge) => Promise<...>;
  edgeX: <Edge extends keyof Edges>(edge: Edge) => Promise<...>;
  patch: (fields: Partial<...>) => Promise<void>;
  replace: (doc: ...) => Promise<void>;
  delete: () => Promise<void>;
};
```

// In auth contexts: ctx.userId is Id<'users'>

// For client-side type patterns, see convex-client.mdc

// ALWAYS type runQuery/runMutation results in actions
const user: { id: string; name: string } | null = await ctx.runQuery(
internal.user.getUser,
{}
);

````

**For client-side TypeScript patterns**, see [convex-client.mdc](mdc:.cursor/rules/convex-client.mdc)

**Rules:** No `any` | No manual complex types | Strict ID types | Type runQuery/runMutation in actions

## Full text search guidelines

**Edit:** `convex/schema.ts` for search indexes

### Define search indexes

```typescript
// convex/schema.ts
export default defineSchema({
  messages: defineTable({
    body: v.string(),
    channel: v.string(),
    userId: v.id('users'),
  }).searchIndex('search_body', {
    searchField: 'body',
    filterFields: ['channel', 'userId'], // Fast equality filters
  }),
});
````

### Run search queries

```typescript
// Basic search with filters
const messages = await ctx
  .table("messages")
  .search(
    "search_body",
    (q) =>
      q
        .search("body", "hello world") // Full-text search
        .eq("channel", "#general") // Filter field
        .eq("userId", userId) // Multiple filters
  )
  .take(10); // Always limit results

// Search with post-filtering (less efficient)
const recent = await ctx
  .table("messages")
  .search("search_body", (q) => q.search("body", "hello"))
  .filter((q) => q.gt(q.field("_creationTime"), Date.now() - 3600000))
  .take(10);
```

For advanced patterns, see [convex-search.mdc](mdc:.cursor/rules/convex-search.mdc).

## Query guidelines

- **CRITICAL: NEVER fetch ALL documents when you only need a subset**:
  - Use `.take(n)` to limit results: `ctx.table('table').take(100)` (default is 100 if not specified)
  - Use `.first()` for single document: `ctx.table('table').first()`, `.firstX()` to throw if not found
  - Use `.get()` for fetching by ID or unique field: `ctx.table('table').get(id)` or `ctx.table('table').get('email', email)`
  - Use `.paginate()` for user-facing lists: see [convex-optimize.mdc](mdc:.cursor/rules/convex-optimize.mdc)
  - Only return all documents when you truly need ALL documents (rare, <1000 docs)
  - **For counts:** Use [convex-aggregate.mdc](mdc:.cursor/rules/convex-aggregate.mdc) instead of `(await ctx.table('table')).length`
- **OPTIMIZATION:** Always use indexes first for filtering:
  - **Use indexes:** Define an index in schema and use it in ctx.table with index filtering
  - **Get by index:** Use `.get('indexName', value)` for unique lookups
  - **Simple cases:** Use built-in `.filter()` for simple field comparisons after indexing
  - **Complex + Paginated:** Use streams from `convex-helpers/server/stream` for consistent page sizes (streams require `ctx.db` in first param only)
  - See [convex-optimize.mdc](mdc:.cursor/rules/convex-optimize.mdc) and [convex-streams.mdc](mdc:.cursor/rules/convex-streams.mdc)
- Ents queries support chaining: `ctx.table('name').filter().take()` or `ctx.table('name', 'index', filter).take()`
- Use `.unique()` to get a single document from a query. This method will throw an error if there are multiple documents that match the query.
- When using async iteration, use the `for await (const row of query)` syntax.
- **System tables:** Access with `ctx.table.system('_storage')` or `ctx.table.system('_scheduled_functions')`
- **Raw documents:** Use `.doc()` or `.docs()` to get plain documents without ent methods
- **Security:** `ctx.table` requires specifying table upfront, preventing accidental cross-table access

### Query Filtering Guidelines

**‚ö†Ô∏è CRITICAL: Use the Right Tool for Filtering**

1. **For simple filters (paginated or not):** Use built-in `.filter()` - maintains full page sizes!
2. **For complex filters WITHOUT pagination:** Use `filter` helper from `convex-helpers/server/filter`
3. **For complex filters WITH pagination:** Use streams from `convex-helpers/server/stream`

**IMPORTANT LIMITATION:** Streams do NOT support `withSearchIndex()`. You cannot combine streams with full-text search indexes. If you need complex filtering with search, you must choose between:

- Using search with only the available filterFields
- Using streams for complex filtering without search
- Implementing separate search and filter flows
  See [convex-search.mdc](mdc:.cursor/rules/convex-search.mdc) for detailed patterns.

| Use Case                             | Tool                 | Why                            |
| ------------------------------------ | -------------------- | ------------------------------ |
| Simple field comparisons             | Built-in `.filter()` | Maintains full page sizes      |
| Complex filters + `.take()/.first()` | `filter` helper      | Full TypeScript, no pagination |
| Complex filters + `.paginate()`      | Streams + `asyncMap` | Consistent page sizes          |

```typescript
// Simple filtering (built-in)
const activeUsers = await ctx
  .table("users", "status", (q) => q.eq("status", "active"))
  .filter((q) => q.gt(q.field("lastSeen"), Date.now() - 3600000))
  .take(10);

// Complex without pagination (filter helper)
import { filter } from "convex-helpers/server/filter";
const featuredPosts = await filter(
  ctx.table("posts", "author", (q) => q.eq("author", authorId)),
  (post) => post.tags.includes("featured") && post.views > 100
).take(10);
// Works with: .first(), .unique(), .take(), .collect()
// DON'T use with: .paginate() (causes variable page sizes)

// Complex with pagination (streams)
import { asyncMap } from "convex-helpers";
import { stream } from "convex-helpers/server/stream";
import schema from "./schema";

export const searchCharacters = createPublicPaginatedQuery()({
  args: {
    category: z.string().optional(),
    tags: z.array(z.string()).optional(),
  },
  handler: async (ctx, args) => {
    const results = await stream(ctx.db, schema) // ‚ö†Ô∏è Stream requires ctx.db here ONLY
      .query("characters")
      .withIndex("private", (q) => q.eq("private", false))
      .filterWith(async (char) => {
        // Full TypeScript power: arrays, strings, async lookups
        if (args.category && !char.categories?.includes(args.category)) {
          return false;
        }
        if (args.tags && !args.tags.some((tag) => char.tags?.includes(tag))) {
          return false;
        }
        // Inside stream operations, use ctx.table()!
        const author = await ctx.table("users").get(char.userId);
        return author && !author.isBanned;
      })
      .paginate(args.paginationOpts); // Always returns requested items!

    // Streams need asyncMap for transformations
    return {
      ...results,
      page: await asyncMap(results.page, async (char) => ({
        ...char,
        user: await ctx.table("users").get(char.userId),
      })),
    };
  },
});
```

For more stream patterns, see [convex-streams.mdc](mdc:.cursor/rules/convex-streams.mdc).

## üö® CRITICAL: Never Use ctx.db

**FORBIDDEN:** `ctx.db` is banned in all Convex functions. Always use `ctx.table()` for database operations.

**ONLY EXCEPTION:** Streams from `convex-helpers/server/stream` still require `ctx.db` in the first parameter only:

```typescript
// ‚ùå NEVER: ctx.db.query('users')
// ‚úÖ ALWAYS: ctx.table('users')

// ‚ö†Ô∏è Exception: Stream initialization ONLY
import { stream } from 'convex-helpers/server/stream';
// Stream requires ctx.db in first parameter
const myStream = stream(ctx.db, schema).query('posts');

// BUT: Inside stream operations, you CAN and SHOULD use ctx.table()!
.filterWith(async (post) => {
  // ‚úÖ Use ctx.table() inside stream operations
  const author = await ctx.table('users').get(post.authorId);
  return author && !author.isBanned;
})
```

### Ordering

- Default: ascending `_creationTime` order
- `.order('asc')` or `.order('desc')` - change sort direction
- `.order('desc', 'numLikes')` - order by index (more efficient than \_creationTime)
- Queries using indexes avoid slow table scans

## Mutation guidelines

### üö® Mutation Checklist

Before implementing any mutation, ensure:

1. **Rate Limiting**: Add `rateLimit` parameter (REQUIRED for user-facing mutations)
   - **‚ö†Ô∏è CRITICAL**: Also add the rate limit definition to `convex/helpers/rateLimiter.ts`!
2. **Validation**: Use Zod schemas for `args` and `returns`
3. **Error Handling**: Throw `ConvexError` with proper codes
4. **Authorization**: Check user permissions if needed
5. **Audit Trail**: Consider logging important actions

```typescript
// ‚úÖ Complete mutation example
export const updateCharacter = createAuthMutation({
  rateLimit: "character/update", // 1. Rate limiting (MUST exist in rateLimiter.ts!)
})({
  args: updateCharacterSchema, // 2. Validation
  returns: z.boolean(),
  handler: async (ctx, args) => {
    const character = await ctx.table("characters").get(args.id);

    if (!character) {
      throw new ConvexError({
        // 3. Error handling
        code: "NOT_FOUND",
        message: "Character not found",
      });
    }

    if (character.userId !== ctx.userId) {
      // 4. Authorization
      throw new ConvexError({
        code: "FORBIDDEN",
        message: "Not authorized",
      });
    }

    await character.patch(args.updates);
    return true;
  },
});
```

### Mutation Operations

- Use `.replace()` to fully replace an existing document: `await ctx.table('users').getX(id).replace(data)`
- Use `.patch()` to shallow merge updates: `await ctx.table('users').getX(id).patch({ name: 'New' })`
- Use `.delete()` to remove a document: `await ctx.table('users').getX(id).delete()`
- Use `.insert()` to create new documents: `await ctx.table('users').insert(data)`
- Use `.insertMany()` to create multiple documents: `await ctx.table('users').insertMany([data1, data2])`. Prefer `insertMany` over for loop `insert`.
- `.getX()` throws if document not found, `.get()` returns null
- Isolate frequently-changing data (timestamps, counters) in separate tables - see [convex-optimize.mdc](mdc:.cursor/rules/convex-optimize.mdc)

### Writing with Ents

```typescript
// Insert and get entity
const task = await ctx.table("tasks").insert({ text: "Build feature" }).get();

// Insert multiple entities
const taskIds = await ctx
  .table("tasks")
  .insertMany([
    { text: "Build feature" },
    { text: "Write tests" },
    { text: "Deploy to production" },
  ]);

// Insert with 1:1 or 1:many edges
await ctx.table("messages").insert({
  text: "Hello world",
  userId, // Creates edge to user
});

// Insert with many:many edges
await ctx.table("messages").insert({
  text: "Tagged message",
  tags: [tagId1, tagId2], // Creates edges to tags
});

// Update many:many edges
await ctx
  .table("messages")
  .getX(messageId)
  .patch({
    tags: { add: [tagId3, tagId4], remove: [tagId1] }, // Add and remove in one operation
  });

// Replace all many:many edges
await ctx
  .table("messages")
  .getX(messageId)
  .replace({
    text: "Updated text",
    tags: [tagId2, tagId3], // Replaces ALL edges (use [] to remove all)
  });

// Replace with edge unchanged - omit edge field
await ctx
  .table("messages")
  .getX(messageId)
  .replace({ text: "Changed text" /* tags unchanged */ });

// Update 1:1 or 1:many edge
await ctx.table("messages").getX(messageId).patch({ userId: newUserId }); // Change parent (use undefined to remove if optional)

// Writing edges during insert
const userId = await ctx.table("users").insert({ name: "Alice" });
const profileId = await ctx
  .table("profiles")
  .insert({ bio: "In Wonderland", userId }); // Creates 1:1 edge

// Writing edges during update
await ctx.table("profiles").getX(profileId).patch({ userId }); // Update edge

// Edge mutations
await ctx
  .table("users")
  .getX(userId)
  .edgeX("profile")
  .patch({ bio: "New bio" });

// ‚ö†Ô∏è LIMITATION: Can't chain edge() on loaded ent for mutations
const user = await ctx.table("users").getX(userId);
// ‚ùå await user.edgeX('profile').patch(...); // TypeScript error
// ‚úÖ WORKAROUND: Start from ctx.table
await ctx.table("users").getX(user._id).edgeX("profile").patch({ bio: "New" });

// Conditional updates with undefined
const updateData: Record<string, any> = {};
if (bio !== undefined) updateData.bio = bio;
if (name !== undefined) updateData.name = name;
if (Object.keys(updateData).length > 0) {
  await ctx.table("users").getX(userId).patch(updateData);
}
```

### Bulk operations

```typescript
// ‚úÖ BEST: Use insertMany for bulk inserts
await ctx.table("items").insertMany(items); // Single operation

// ‚úÖ GOOD: Loop inserts are still efficient - Convex batches in single transaction
for (const item of items) {
  await ctx.table("items").insert(item);
}

// ‚ùå AVOID: Unnecessary Promise.all - adds complexity without benefit
await Promise.all(items.map((item) => ctx.table("items").insert(item)));

// Process large datasets in batches of 100-1000
const batchSize = 500;
for (let i = 0; i < items.length; i += batchSize) {
  const batch = items.slice(i, i + batchSize);
  await ctx.table("items").insertMany(batch);
}
```

**Ents .map():** Works directly on queries | **asyncMap:** Only for non-Ent arrays

## Action guidelines

- Always add `"use node";` to the top of files containing actions that use Node.js built-in modules.
- Never use `ctx.table` or `ctx.db` inside of an action. Actions don't have access to the database.
- Use `createAction()` for public actions and `createInternalAction()` for internal actions:

```ts
"use node";

import { createAction } from "./functions";
import { z } from "zod";

// Public action
export const exampleAction = createAction()({
  args: {},
  returns: z.null(),
  handler: async (ctx, args) => {
    console.info("This action does not return anything");
    return null;
  },
});
```

## Scheduling guidelines

For cron jobs and scheduling patterns, see [convex-scheduling.mdc](mdc:.cursor/rules/convex-scheduling.mdc).

## Examples

For complete examples including chat applications and other patterns, see [convex-examples.mdc](mdc:.cursor/rules/convex-examples.mdc).

## Deletion Behaviors

**Edit:** `convex/schema.ts`

Convex Ents automatically handles cascading deletes. **Hard deletion is now the default behavior** - when you delete an ent, related ents are automatically hard deleted based on edge relationships:

```typescript
defineEnt({
  name: v.string(),
})
  .deletion('soft') // Soft delete with deletionTime field
  .deletion('scheduled', { delayMs: 24 * 60 * 60 * 1000 }) // Delete after 24h
  .edge('profile') // Profile is automatically deleted when user is deleted (default: hard)
  .edge('profile', { deletion: 'hard' }) // Override deletion for 1:1 edges
  .edge('files', { to: '_storage' }); // Files are automatically deleted (default: hard)

// Soft delete operations
await ctx.table('users').getX(userId).delete(); // Sets deletionTime
await ctx.table('users').getX(userId).patch({ deletionTime: undefined }); // Undelete

// Soft edge deletion for 1:1/1:many
.edges('profiles', { ref: true, deletion: 'soft' }) // Cascade soft delete
```

For detailed deletion patterns and rules, see [convex-ents.mdc](mdc:.cursor/rules/convex-ents.mdc).

## Triggers

**Edit:** `convex/triggers.ts`, `convex/functions.ts`

```typescript
// Setup in functions.ts
import { Triggers } from "convex-helpers/server/triggers";
export const triggers = new Triggers<DataModel>();
import "./triggers"; // Import trigger registrations

// Register triggers for aggregates and validation
// Aggregate maintenance - ALWAYS use .trigger()
triggers.register("characterWorks", aggregateCharacterWorks.trigger());

// Data validation
triggers.register("users", async (ctx, change) => {
  if (change.newDoc && !change.newDoc.email.includes("@")) {
    throw new Error("Invalid email");
  }
});
```

For complete documentation, see [convex-trigger.mdc](mdc:.cursor/rules/convex-trigger.mdc).

## Convex Aggregate

**Edit:** `convex/aggregates.ts`

**CRITICAL for Scale:** Use aggregates instead of `.collect().length` for counts. O(log n) vs O(n) performance.

**üö® CRITICAL: ALWAYS use triggers to keep aggregates in sync. NEVER update aggregates manually in mutations.**

```typescript
// ‚ùå INEFFICIENT: Fetches all documents just to count
const count = (await ctx.table('scores')).length;

// ‚úÖ EFFICIENT: O(log n) count operation with triggers
const leaderboard = new TableAggregate<...>(components.leaderboard, {
  namespace: (doc) => doc.gameId,
  sortKey: (doc) => doc.score,
});

// STEP 1: Register component in convex/convex.config.ts
// app.use(aggregate, { name: 'leaderboard' });

// STEP 2: Set up automatic aggregate updates in triggers.ts
triggers.register('scores', leaderboard.trigger());

// STEP 3: In mutations - Just do normal operations, triggers handle aggregates!
await ctx.table('scores').insert(data); // That's it! Aggregate updates automatically

// STEP 4: Read O(log n) operations
const count = await leaderboard.count(ctx, { namespace: gameId });
const rank = await leaderboard.indexOf(ctx, score);

// ‚ùå NEVER do manual updates
await leaderboard.insert(ctx, doc); // WRONG!
await leaderboard.delete(ctx, doc); // WRONG!
```

### Bounds requirement for null keys

**IMPORTANT**: When using `sortKey: () => null`, the aggregate requires `bounds` to be explicitly provided:

```typescript
// Aggregate with null key (no sorting)
const countAggregate = new TableAggregate<{
  Key: null;
  DataModel: DataModel;
  TableName: "items";
}>(components.countAggregate, {
  sortKey: () => null,
});

// ‚ùå WRONG: Missing bounds parameter
const count = await countAggregate.count(ctx, {
  namespace: itemId,
});

// ‚úÖ CORRECT: Include empty bounds for unbounded counting
const count = await countAggregate.count(ctx, {
  namespace: itemId,
  bounds: {} as any,
});
```

This is because aggregates with `null` keys don't have natural ordering, so bounds must be explicitly specified to indicate you want all items.

**‚ö†Ô∏è IMPORTANT:** All aggregate components must be registered in `convex/convex.config.ts` before they can be used.

For more aggregate patterns, see [convex-aggregate.mdc](mdc:.cursor/rules/convex-aggregate.mdc).

## Shared Code Organization

- **Shared helpers**: ALWAYS move shared code from `src/` to `convex/shared/` instead of duplicating
- **Model exception**: `[modelName]Shared.ts` can be next to `[modelName].ts`, not in `convex/shared/` folder
- **Import paths**:
  - From Convex: `import { helper } from './shared/filename'` or `import { helper } from './characterShared'`
  - From Next.js: `import { helper } from '@convex/shared/filename'` or `import { helper } from '@convex/characterShared'`
